<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>番組尺計算タイムライン</title>
    <style>
        /* スタイルは変更なしのため、ここでは省略します。 */
        /* ... (既存のCSS) ... */

        /* 入力エラー表示用のスタイルを追加 */
        .input-error {
            border-color: red !important;
        }
        .error-message {
            color: red;
            font-size: 0.8em;
            margin-top: 4px;
            display: block; /* 必要に応じて */
        }
    </style>
</head>
<body>
    <script>
        "use strict";

        // 定数 (変更なし)
        const MAX_BLOCKS = 100;
        const MAX_NAME_LENGTH = 50;
        const MAX_PRESETS = 20;
        const MAX_PRESET_NAME_LENGTH = 30;
        const COLOR_OPTIONS = {
            "明るいピンク": "#FFD1D1", "クリーム": "#FFFF99", "明るい青緑": "#CBF266",
            "明るい空色": "#B4EBFA", "ベージュ": "#EDC58F", "明るい緑": "#87E7B0", "明るい紫": "#C7B2DE"
        };
        const COLOR_NAMES = Object.keys(COLOR_OPTIONS);
        const DEFAULT_BLOCK_COLOR_NAME = "明るい空色";

        // --- セキュリティ対策と改善 ---

        /**
         * 文字列をHTMLエスケープする関数 (XSS対策)
         * @param {string} str エスケープする文字列
         * @returns {string} エスケープされた文字列
         */
        function sanitizeHTMLString(str) {
            if (typeof str !== 'string') return '';
            const map = {
                '&': '&amp;', '<': '&lt;', '>': '&gt;',
                '"': '&quot;', "'": '&#39;'
            };
            return str.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        /**
         * HH:MM:SS形式の時刻文字列を検証する関数
         * @param {string} timeStr 検証する時刻文字列
         * @returns {boolean} 有効な場合はtrue、そうでない場合はfalse
         */
        function isValidTimeFormat(timeStr) {
            if (typeof timeStr !== 'string') return false;
            return /^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(timeStr);
        }

        /**
         * 時間長 (HH:MM:SS, MM:SS, SS, または単なる秒数) の文字列を検証する関数
         * @param {string} durationStr 検証する時間長文字列
         * @returns {boolean} 有効な場合はtrue、そうでない場合はfalse
         */
        function isValidDurationFormat(durationStr) {
            if (typeof durationStr !== 'string') return false;
            if (/^\d+$/.test(durationStr)) return true; // 単なる秒数
            const parts = durationStr.split(':');
            if (parts.length === 0 || parts.length > 3) return false;
            return parts.every(part => /^[0-5]?\d$/.test(part) && part.length <= 2);
        }
        
        // ユーティリティ関数: エラーメッセージの表示・非表示
        function displayValidationError(inputElement, message, showError) {
            let errorMsgElement = inputElement.parentNode.querySelector(`.error-message[data-for="${inputElement.id}"]`);
            if (showError) {
                inputElement.classList.add('input-error');
                if (!errorMsgElement) {
                    errorMsgElement = document.createElement('div');
                    errorMsgElement.className = 'error-message';
                    errorMsgElement.dataset.for = inputElement.id; // エラーメッセージを特定の入力に関連付ける
                    inputElement.parentNode.insertBefore(errorMsgElement, inputElement.nextSibling);
                }
                errorMsgElement.textContent = message;
            } else {
                inputElement.classList.remove('input-error');
                if (errorMsgElement) {
                    errorMsgElement.remove();
                }
            }
        }


        // 初期データ (名前をサニタイズ)
        let blocksData = [
            {id: "block_0", name: sanitizeHTMLString("VTR①"), duration_sec: 540, color_name: "明るい空色"},
            {id: "block_1", name: sanitizeHTMLString("CM①"), duration_sec: 180, color_name: "ベージュ"},
            {id: "block_2", name: sanitizeHTMLString("VTR②"), duration_sec: 780, color_name: "明るい空色"},
            {id: "block_3", name: sanitizeHTMLString("CM②"), duration_sec: 180, color_name: "ベージュ"},
            {id: "block_4", name: sanitizeHTMLString("VTR③"), duration_sec: 660, color_name: "明るい空色"},
            {id: "block_5", name: sanitizeHTMLString("CM③"), duration_sec: 180, color_name: "ベージュ"},
            {id: "block_6", name: sanitizeHTMLString("VTR④"), duration_sec: 480, color_name: "明るい空色"}
        ];
        let nextBlockIdCounter = blocksData.length;

        let savedPresets = [
            {
                id: "preset_default_1",
                name: sanitizeHTMLString("標準1時間番組"),
                blocks: [
                    {name: sanitizeHTMLString("オープニング"), duration_sec: 120, color_name: "明るい青緑"},
                    {name: sanitizeHTMLString("VTR①"), duration_sec: 900, color_name: "明るい空色"},
                    {name: sanitizeHTMLString("CM①"), duration_sec: 180, color_name: "ベージュ"},
                    {name: sanitizeHTMLString("VTR②"), duration_sec: 1200, color_name: "明るい空色"},
                    {name: sanitizeHTMLString("CM②"), duration_sec: 180, color_name: "ベージュ"},
                    {name: sanitizeHTMLString("エンディング"), duration_sec: 180, color_name: "明るい青緑"}
                ],
                createdAt: "2024/05/20 10:00:00"
            }
        ];
        let nextPresetIdCounter = savedPresets.length + 1;

        // DOM要素の取得
        const startTimeInput = document.getElementById('startTime');
        const targetTimeInput = document.getElementById('targetTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const diffTimeDisplay = document.getElementById('diffTime');
        const timelineContainer = document.getElementById('timelineContainer');
        const blocksContainer = document.getElementById('blocksContainer');
        const addBlockBtn = document.getElementById('addBlockBtn');
        const limitWarningDiv = document.getElementById('limitWarning');
        const presetBtn = document.getElementById('presetBtn');
        const presetModal = document.getElementById('presetModal'); // showPresetModal等から参照
        const presetNameInput = document.getElementById('presetNameInput'); // saveCurrentPreset等から参照
        
        // プリセット管理機能
        window.showPresetModal = function() { // HTMLのonclickから呼び出されるためグローバルに公開
            if (!presetModal) return;
            presetModal.style.display = 'block';
            buildPresetList();
            if (presetNameInput) {
                presetNameInput.value = '';
                displayValidationError(presetNameInput, '', false); // エラー表示をクリア
            }
            presetModal.onclick = function(event) {
                if (event.target === presetModal) {
                    window.hidePresetModal();
                }
            };
        }

        window.hidePresetModal = function() { // HTMLのonclickから呼び出されるためグローバルに公開
            if (presetModal) {
                presetModal.style.display = 'none';
            }
        }

        window.saveCurrentPreset = function() { // HTMLのonclickから呼び出されるためグローバルに公開
            if (!presetNameInput) return;
            displayValidationError(presetNameInput, '', false); // 既存エラーをクリア

            let nameValue = presetNameInput.value.trim();

            if (!nameValue) {
                displayValidationError(presetNameInput, 'プリセット名を入力してください。', true);
                alert('プリセット名を入力してください。'); // 既存のalertも残す場合
                return;
            }
            if (nameValue.length > MAX_PRESET_NAME_LENGTH) {
                displayValidationError(presetNameInput, `プリセット名は${MAX_PRESET_NAME_LENGTH}文字以内で入力してください。`, true);
                alert(`プリセット名は${MAX_PRESET_NAME_LENGTH}文字以内で入力してください。`);
                return;
            }

            const sanePresetName = sanitizeHTMLString(nameValue);

            if (savedPresets.length >= MAX_PRESETS) {
                alert(`最大${MAX_PRESETS}個までしか保存できません。`);
                return;
            }

            const currentBlocks = blocksData.map(block => ({
                name: block.name, // blocksData内のnameは既にサニタイズ済みと仮定
                duration_sec: block.duration_sec,
                color_name: block.color_name
            }));

            const newPreset = {
                id: `preset_${Date.now()}`, // IDの一意性を高める
                name: sanePresetName,
                blocks: currentBlocks,
                createdAt: new Date().toLocaleString('ja-JP')
            };

            savedPresets.push(newPreset);
            nextPresetIdCounter++; // これはID生成ロジックによる (Date.now()なら不要かも)

            buildPresetList();
            presetNameInput.value = '';

            const saveBtn = document.querySelector('#presetModal .save-preset-btn');
            if (saveBtn) {
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '✅ 保存しました！';
                saveBtn.disabled = true;
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.disabled = false;
                }, 2000);
            }
        }

        function loadPreset(presetId) { // buildPresetListから呼ばれるのでグローバルでなくても良いが、現状維持
            const preset = savedPresets.find(p => p.id === presetId);
            if (!preset) return;

            // preset.nameはサニタイズ済みなので、confirmダイアログではそのまま使用可能
            if (!confirm(`「${preset.name}」を読み込みますか？\n現在の構成は上書きされます。`)) {
                return;
            }

            blocksData = preset.blocks.map((block, index) => ({
                id: `block_${Date.now()}_${index}`, // 新しいIDを付与
                name: sanitizeHTMLString(block.name), // 念のため再サニタイズ
                duration_sec: block.duration_sec,
                color_name: block.color_name
            }));
            nextBlockIdCounter = blocksData.length;

            // updateAll(); // 描画更新 (この関数は未提示)
            console.log("TODO: updateAll() を呼び出してUIを更新してください。");
            window.hidePresetModal();

            setTimeout(() => {
                alert(`「${preset.name}」を読み込みました。`);
            }, 100);
        }

        function deletePreset(presetId) { // buildPresetListから呼ばれる
            const preset = savedPresets.find(p => p.id === presetId);
            if (!preset) return;

            if (!confirm(`「${preset.name}」を削除しますか？\nこの操作は取り消せません。`)) {
                return;
            }
            savedPresets = savedPresets.filter(p => p.id !== presetId);
            buildPresetList();
        }

        function buildPresetList() {
            const container = document.getElementById('presetList');
            if (!container) return;
            container.innerHTML = ''; // 既存の子要素をクリア

            if (savedPresets.length === 0) {
                const noPresets = document.createElement('div');
                noPresets.className = 'no-presets';
                noPresets.textContent = 'まだプリセットが保存されていません。'; // textContent で安全
                container.appendChild(noPresets);
                return;
            }

            savedPresets.forEach(preset => {
                const item = document.createElement('div');
                item.className = 'preset-item';

                const info = document.createElement('div');
                info.className = 'preset-info';
                const nameDiv = document.createElement('div');
                nameDiv.className = 'preset-name';
                nameDiv.textContent = preset.name; // textContent で安全 (preset.name はサニタイズ済み)
                info.appendChild(nameDiv);

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'preset-details';
                const totalSeconds = preset.blocks.reduce((sum, block) => sum + block.duration_sec, 0);
                // secondsToHHMMSS 関数が未提示のため、仮の実装
                const formattedTotalDuration = `${Math.floor(totalSeconds / 3600).toString().padStart(2, '0')}:${Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0')}:${(totalSeconds % 60).toString().padStart(2, '0')}`;
                detailsDiv.textContent = `${preset.blocks.length}ブロック | ${formattedTotalDuration} | ${preset.createdAt}`; // textContent で安全
                info.appendChild(detailsDiv);
                item.appendChild(info);

                const actions = document.createElement('div');
                actions.className = 'preset-actions';
                const loadBtn = document.createElement('button');
                loadBtn.className = 'load-btn';
                loadBtn.textContent = '読み込み';
                loadBtn.addEventListener('click', () => loadPreset(preset.id));
                actions.appendChild(loadBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-preset-btn';
                deleteBtn.textContent = '削除';
                deleteBtn.addEventListener('click', () => deletePreset(preset.id));
                actions.appendChild(deleteBtn);
                item.appendChild(actions);

                container.appendChild(item);
            });
        }

        // 時刻入力フィールドのバリデーションイベントリスナー
        if (startTimeInput) {
            startTimeInput.addEventListener('blur', () => {
                const isValid = isValidTimeFormat(startTimeInput.value);
                displayValidationError(startTimeInput, '不正な時刻形式です (HH:MM:SS)。', !isValid && startTimeInput.value !== '');
                if (isValid) { /* updateAll(); */ }
            });
        }
        if (targetTimeInput) {
            targetTimeInput.addEventListener('blur', () => {
                // 目標時間は HH:MM:SS 形式を期待
                const isValid = isValidTimeFormat(targetTimeInput.value);
                displayValidationError(targetTimeInput, '不正な時刻形式です (HH:MM:SS)。', !isValid && targetTimeInput.value !== '');
                if (isValid) { /* updateAll(); */ }
            });
        }

        // プリセット管理ボタンのイベントリスナー
        if (presetBtn) {
            presetBtn.addEventListener('click', window.showPresetModal);
        }
        
        // TODO: 以下の関数の実装と、それらにおけるセキュリティ対策（サニタイズ、入力検証）が必要です。
        // - updateAll() : 全体のUIを再描画するメイン関数。ここでtextContentや安全なDOM操作を徹底。
        // - buildTimeline() : タイムライン表示。ブロック名はtextContentで。
        // - buildBlockRow() : ブロック管理行の生成。
        //   - ブロック名入力: valueプロパティで設定、変更時はsanitizeHTMLStringでサニタイズ。maxLength属性も活用。
        //   - 時間入力: blurイベントでisValidDurationFormatを使って検証。エラーフィードバック。
        // - addBlock() : 新規ブロック追加。デフォルト名もサニタイズ。
        // - secondsToHHMMSS() / timeInputToSeconds() : 時刻変換関数。不正入力への対応。
        // - showTextOutput() / hideTextOutput() / copyToClipboard() : テキスト出力関連。出力内容のエスケープに注意。

        console.log("セキュリティ対策が一部適用されました。未提示の関数 (updateAll, buildBlockRowなど) にも同様の対策を施してください。");

    </script>
</body>
</html>
